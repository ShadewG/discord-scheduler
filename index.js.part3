      await interaction.reply(`‚ùå Error scheduling meeting: ${cmdError.message}`);
      hasResponded = true;
    } else {
      await interaction.editReply(`‚ùå Error scheduling meeting: ${cmdError.message}`);
    }
  }
}

// Add custom meetings support
const meetingsFilePath = path.join(__dirname, 'meetings.json');
const customMeetings = [];

// Load meetings from file
function loadMeetings() {
  if (fs.existsSync(meetingsFilePath)) {
    try {
      const data = fs.readFileSync(meetingsFilePath, 'utf8');
      const loadedMeetings = JSON.parse(data);
      logToFile(`Loaded ${loadedMeetings.length} existing meetings from file`);
      return loadedMeetings;
    } catch (error) {
      logToFile(`Error loading meetings file: ${error.message}`);
    }
  } else {
    logToFile('No meetings.json file found. Starting with empty meetings list.');
  }
  return [];
}

// Save meetings to file
function saveMeetings() {
  if (customMeetings.length === 0) {
    logToFile('No meetings to save');
    return;
  }
  
  fs.writeFileSync(meetingsFilePath, JSON.stringify(customMeetings, null, 2));
  logToFile(`Saved ${customMeetings.length} meetings to meetings.json`);
}

// Parse a time string into a Date
function parseTimeString(timeStr) {
  const now = new Date();
  
  // Handle relative time format (e.g., "30m" for 30 minutes from now)
  const relativeMatch = timeStr.match(/^(\d+)([mh])$/i);
  if (relativeMatch) {
    const [_, amount, unit] = relativeMatch;
    const milliseconds = unit.toLowerCase() === 'm' 
      ? parseInt(amount) * 60 * 1000 // minutes
      : parseInt(amount) * 60 * 60 * 1000; // hours
    
    const futureTime = new Date(now.getTime() + milliseconds);
    return futureTime;
  }
  
  // Handle absolute time format (e.g., "1400" for 2:00 PM today)
  const absoluteMatch = timeStr.match(/^(\d{1,2})(\d{2})$/);
  if (absoluteMatch) {
    const [_, hours, minutes] = absoluteMatch;
    const futureTime = new Date(now);
    futureTime.setHours(parseInt(hours));
    futureTime.setMinutes(parseInt(minutes));
    futureTime.setSeconds(0);
    
    // If the time is in the past, assume it's for tomorrow
    if (futureTime < now) {
      futureTime.setDate(futureTime.getDate() + 1);
    }
    
    return futureTime;
  }
  
  // Return null if format is not recognized
  return null;
}

// Send a DM to a user
async function sendDirectMessage(userId, message) {
  try {
    const user = await client.users.fetch(userId);
    await user.send(message);
    logToFile(`Sent DM to ${user.tag}: ${message}`);
    return true;
  } catch (error) {
    logToFile(`Error sending DM to user ${userId}: ${error.message}`);
    return false;
  }
}

// Check for upcoming meetings and send reminders
async function checkMeetings() {
  if (customMeetings.length === 0) return;
  
  const now = new Date();
  
  // Check each meeting
  for (let i = customMeetings.length - 1; i >= 0; i--) {
    const meeting = customMeetings[i];
    
    // Skip if already notified
    if (meeting.notified) continue;
    
    // Parse the meeting time
    const meetingTime = meeting.scheduledTime 
      ? new Date(meeting.scheduledTime) 
      : parseTimeString(meeting.time);
    
    // Store the parsed time back to the meeting
    if (!meeting.scheduledTime && meetingTime) {
      meeting.scheduledTime = meetingTime.toISOString();
      saveMeetings();
    }
    
    // If time couldn't be parsed, skip
    if (!meetingTime) continue;
    
    // Calculate the reminder time (10 minutes before meeting)
    const reminderTime = new Date(meetingTime.getTime() - 10 * 60 * 1000);
    
    // Check if it's time for the reminder
    if (now >= reminderTime && now < meetingTime) {
      // Send reminders
      const topicText = meeting.topic ? ` about "${meeting.topic}"` : '';
      const timeText = meetingTime.toLocaleTimeString('en-US', {
        hour: 'numeric',
        minute: '2-digit',
        hour12: true
      });
      
      // Remind the creator
      await sendDirectMessage(
        meeting.createdBy,
        `üîî Reminder: Your meeting${topicText} with <@${meeting.participant}> starts in 10 minutes (${timeText})!`
      );
      
      // Remind the participant
      await sendDirectMessage(
        meeting.participant,
        `üîî Reminder: <@${meeting.createdBy}> has scheduled a meeting${topicText} with you in 10 minutes (${timeText})!`
      );
      
      // Mark as notified
      meeting.notified = true;
      saveMeetings();
      
      logToFile(`Sent reminders for meeting ${meeting.id}`);
    }
    
    // Remove meetings that are more than an hour old
    if (meetingTime && (now.getTime() - meetingTime.getTime() > 60 * 60 * 1000)) {
      customMeetings.splice(i, 1);
      saveMeetings();
      logToFile(`Removed old meeting ${meeting.id}`);
    }
  }
}

// Schedule meeting checks
setInterval(checkMeetings, 60 * 1000); // Check every minute

// Load existing meetings
const loadedMeetings = loadMeetings();
if (loadedMeetings && loadedMeetings.length > 0) {
  customMeetings.push(...loadedMeetings);
}